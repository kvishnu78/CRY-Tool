%% Image Encryption and Decryption
%Author: Vishnu K
%last updated:8 Nov 2020
%Encrption, decryption and Key generation for a Public key cryptography scheme using
%Hill cipher and Elliptical Curve Cryptography(ECC) for Images
%Ideal for images with column pixcel count as multiple of 4 
%% READING IMAGE
img =(imread('input_landscape.jpg'));
[a b c]=size(img);
if(c==3)
    img=rgb2gray(img);
end
img=im2double(img);
input=img;
figure,imshow(img);
%% KEY GENERATION by sender and reciever
%general equation E:y^2=x^3+ax+b mod p
%p!=2,3
%a,b belongs to F, and 4a^3+27b^2!=0(mod p)
%Elliptic curve group E(F) cosists of all points that
%satisfy the curve E
%y^2=x^3+x+3(mod 31) Elliptic Curve equation used in the following
%implementation
%4(1)^3+27(3)^2 != 0(mod p)
%so E31=(a,b)=(1,3)
%Generator point or base point,G=(1,6), can be any other point that satisfies
%the equation and generates a cyclic group
xi=1;
yi=6;
%such that 
na=13;% 1<=13<=30, private key of sender
Pa=[3,23];%Pa=na*G=13(1,6)=(3,23)
Ki=[20,5];%Ki=na*Pb=13(24,5)=(x,y) Initial Key, Pb is th public key of Reciever
K1=[4,28];%K1=x*G=20(1,6)
K2=[15,18];%K2=y*G=5(1,6)
I=eye(2);
K11=[K1;K2];
K12=I-K11;
K21=I+K11;
K22=-1*K11;
Km=[K11,K12;K21,K22];%self invertible key matrix generated by both th users

%Similarly reciever also generated the Km Key matrix
%nb=17;
%Pb=17(1,6)=(24,5)
%Ki=nb*Pa=17(3,23)=(20,5)=(x,y) Initial Key
%Compute K1,K2 as above

%% PARAMETERS
%PUBLIC PARAMETERS:
%Pa,Pb,G,E

%PRIVATE PARAMETERS
%Na,Nb,Km
%% ENCRYPTION
i=1;
while(i<=a)
    j=1;
    while(j<=b)
        p=[double(input(i,j));double(input(i,j+1));double(input(i,j+2));double(input(i,j+3))];
        t=Km*p;
        input(i,j)=(mod(t(1),256));
        input(i,j+1)=(mod(t(2),256));
        input(i,j+2)=(mod(t(3),256));
        input(i,j+3)=(mod(t(4),256));
        j=j+4;
    end
    i=i+1;
end
%Open this to display the encryption results
figure,imshow(input);

%% DECRYPTION
i=1;
while(i<=a)
    j=1;
    while(j<=b)
        p=[double(input(i,j));double(input(i,j+1));double(input(i,j+2));double(input(i,j+3))];
        t=Km*p;
        input(i,j)=(mod(t(1),256));
        input(i,j+1)=(mod(t(2),256));
        input(i,j+2)=(mod(t(3),256));
        input(i,j+3)=(mod(t(4),256));
        j=j+4;
    end
    i=i+1;
end
%Open this to display the decryption results
figure,imshow(input);



%% FUNCTIONS
%MODULAR INVERSE FUNCTION
i=1;
function x = modinv(a,m)
    m0=m;
    y=0;
    x=1;
    if(m==1);
        return;
    end
    while(a>1)
        q=floor(a/m);%quotient
        t=m;
        %finding remainder 
        m=rem(a,m);
        a=t;
        t=y;
        %updating x and y
        y=x-q*y;
        x=t;
    end
    if (x<0)
        x=x+m0;
    end
end



